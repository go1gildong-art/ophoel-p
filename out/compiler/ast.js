"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BuildAST = exports.AST = exports.Location = void 0;
function makeNode(type, location) {
    return { type, location };
}
class Location {
    constructor(fileName, line, tokenIdx = null) {
        this.fileName = fileName;
        this.line = line;
        this.tokenIdx = tokenIdx;
    }
}
exports.Location = Location;
class AST {
    constructor(ast) {
        var _a, _b, _c, _d, _e, _f, _g;
        // ---------- GENERAL ----------
        // holds the node type. McCommand, Literal, VariableDecl, etc
        // Uses: ALL
        // Type: string
        this.type = ast.type;
        // holds the location of the node with Location object
        // Uses: ALL
        // Type: Location
        this.location = ast.location;
        // ---------- DECLARATION ----------
        // holds the type for variable or function declaration
        // Uses: VariableDecl, FunctionDecl, MacroDecl
        // Type: string
        this.varType = ast.varType;
        // holds the name for variable or function declaration
        // Uses: VariableDecl, FunctionDecl, MacroDecl
        // Type: string
        this.varName = ast.varName;
        // holds the assigned value for declarations
        // Uses: VariableDecl
        // Type: AST
        this.varValue = ast.varValue;
        // holds the array of assigned parameters for declarations
        // Uses: FunctionDecl, MacroDecl
        // Type: string[]
        this.varParam = (_a = ast.varParam) !== null && _a !== void 0 ? _a : [];
        // holds the code block body for declarations
        // Uses: FunctionDecl, MacroDecl
        // Type: AST(block)
        this.varBody = (_b = ast.varBody) !== null && _b !== void 0 ? _b : [];
        // ---------- CALLS & INVOCATIONS ----------
        // holds the name for invoked value
        // Uses: Identifier, FunctionCall, MacroInvoc
        // Type: string
        this.name = ast.name;
        // holds an array of arguments passed inside
        // Uses: IfStatement, WhileStatement, ForStatement, 
        // Uses: RepeatStatement, McExecStatement,
        // Uses: FunctionCall, MacroInvoc
        // Type: AST[]
        this.args = (_c = ast.args) !== null && _c !== void 0 ? _c : [];
        // holds an array of nodes as code block
        // Uses: IfStatement, WhileStatement, ForStatement, 
        // Uses: RepeatStatement, McExecStatement, Block,
        // Uses: FunctionCall, MacroInvoc, Program
        // Type: AST(block) (AST[] for Program node)
        this.body = (_d = ast.body) !== null && _d !== void 0 ? _d : [];
        // ---------- EXPRESSIONS ----------
        // holds the value's type that the node would have
        // Uses: Literal, TemplateStringLiteral,
        // Uses: Identifier, FunctionCall, MacroInvoc
        // Type: string
        this.valueType = ast.valueType;
        // holds the value that the node would finally have
        // Uses: Literal, TemplateStringLiteral,
        // Uses: Identifier, FunctionCall?, MacroInvoc?, 
        // Uses: ConfigRef
        // Type: Primitive
        this.value = ast.value;
        // holds the operation the node performs
        // Uses: UnaryExpression, BinaryExpression
        // Type: string
        this.operator = ast.operator;
        // holds the leftside value 
        // Uses: UnaryExpression, BinaryExpression
        // Type: AST
        this.left = ast.left;
        // holds the rightside value 
        // Uses: UnaryExpression, BinaryExpression
        // Type: AST
        this.right = ast.right;
        // ---------- MISC ----------
        // holds the array of quasis strings for a template string
        // Uses: TemplateStringLiteral
        // Type: string[]
        this.templateQuasis = (_e = ast.templateQuasis) !== null && _e !== void 0 ? _e : [];
        // holds the array of expression nodes for a template string
        // Uses: TemplateStringLiteral
        // Type: AST[]
        this.templateExpressions = (_f = ast.templateExpressions) !== null && _f !== void 0 ? _f : [];
        // holds the command for minecraft commands
        // Uses: McCommand
        // Type: string
        this.command = ast.command;
        // holds the value of whole preserved comment (including /# part!)
        // Uses: PreservedCommand
        // Type: string
        this.message = ast.message;
        // holds the execute prefix for minecraft command
        // Only generated by transformer
        // Uses: McCommand
        // Type: AST[]
        this.prefixes = (_g = ast.prefixes) !== null && _g !== void 0 ? _g : [];
    }
    setValue(value) {
        this.value = value;
    }
}
exports.AST = AST;
exports.BuildAST = {
    // 1. Statements (top level items)
    Program: (body, location) => ({
        ...makeNode('Program', location),
        body: exports.BuildAST.Block(body, location)
    }),
    Block: (body, location) => ({
        ...makeNode('Block', location),
        body
    }),
    VariableDecl: (varType, varName, mutability, varValue, location) => ({
        ...makeNode('VariableDecl', location),
        varType,
        varName,
        varValue,
        mutability
    }),
    VariableAssign: (varName, varValue, location) => ({
        ...makeNode('VariableAssign', location),
        varName,
        varValue,
    }),
    VariableAssignShorten: (varName, varValue, operator, location) => ({
        ...makeNode('VariableAssignShorten', location),
        varName,
        varValue,
        operator
    }),
    McCommand: (command, args, location) => {
        return ({
            ...makeNode('McCommand', location),
            command,
            args
        });
    },
    // 2. Expressions (nested math/logic)
    BinaryExpression: (operator, left, right, hasParenthesis, location) => ({
        ...makeNode("BinaryExpression", location),
        operator, // +-*/
        left, // node
        right, // node
        hasParenthesis
    }),
    Literal: (valueType, raw, location) => {
        return ({
            ...makeNode('Literal', location),
            valueType,
            raw, // string source
        });
    },
    TemplateStringLiteral: (templateQuasis, templateExpressions, raw, location) => ({
        ...makeNode('TemplateStringLiteral', location),
        templateQuasis, // array of strings
        templateExpressions, // array of expressions, go between quasis strings
        raw, // raw string entered
        valueType: "string"
    }),
    Identifier: (name, location) => ({
        ...makeNode('Identifier', location),
        name
    }),
    ConfigRef: (access, location) => ({
        ...makeNode('ConfigRef', location),
        access
    }),
    // 3. Control flows & Macro invocations
    RepeatStatement: (args, body, location) => ({
        ...makeNode("RepeatStatement", location),
        args,
        body: exports.BuildAST.Block(body, location)
    }),
    McExecStatement: (args, body, location) => ({
        ...makeNode("McExecStatement", location),
        args,
        body: exports.BuildAST.Block(body, location)
    }),
    // 4. Perserved comments (appear on compiled mcfunction)
    PreservedComment: (message, location) => ({
        ...makeNode("PreservedComment", location),
        message,
    }),
    PreservedNewline: (message, location) => ({
        ...makeNode("PreservedNewline", location),
        message,
    }),
    Comment: (commentMessage, location) => ({
        ...makeNode("Comment", location),
        commentMessage,
    })
};
/*
field meanings:

*/ 
//# sourceMappingURL=ast.js.map